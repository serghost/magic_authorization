### Способ "умной" авторизации

Авторизация - это процесс проверки прав пользователя на выполнение определенных операций.

Рассмотрим несколько примеров из реальной жизни для получения интуиции:

Можно представить себе КПП рядом с воинской частью. Для того, чтобы пройти на территорию части, вам нужно предъявить документ, где указано, что вы являетесь служащим, которому разрешен проход в часть. Подчеркнём, что проверяющему не важно, как вас зовут и кем конкретно вы являетесь (в этом и главное отличие авторизации от аутентификации).
Другой пример: вы студент и имеете право на льготный проезд. Многим кондукторам достаточно взглянуть на корочку студенческого билета, чтобы понять, что оплата у вас по скидке.

В web-мире всё даже проще. В подавляющем большинстве случаев авторизация - это некая функция проверки прав на осуществление некого действия, которое полностью определяется HTTP-запросом. Я не случайно обратил здесь внимание на HTTP-запрос. Любое действие можно представить как манипуляцию с информацией. Попробуем "смаппить" ситуации из реальной жизни в веб.
Вход в военную часть - это что-то вроде GET запроса на ресурс, где представлена информация о объектах в части и проч. `GET /military_base -> { objects: { barracks: [build_1: { square: ... , floors: ... , persons: ..., }]}, {silos: [] } ... }`. Здесь же хочу отметить stateless природу HTTP. Когда вы входите в часть, "авторизовываетесь" в КПП, вы автоматически получаете право на некоторые дейтсвия внутри части: сходить в столовую, пользоваться библиотекой и т.п. Хотя, конечно, в части могут быть объекты, которые требуют повышенных прав. Тогда, конечно, требуется новая авторизация. В мире HTTP такой "иерархии" авторизаций нет. Если вы авторизовались для `GET /military_base` это не значит, что теперь система "знает" о том, что вас нужно пропускать и в `GET /military_base/library`. Каждый новый запрос требует новой авторизации, совершенно не важно, как были совершены предыдущие запросы - состояния не хранится.





Первоначальная идея в том, чтобы по роли пользователя определять, имеет ли он право совершать операции с найденной по id из запроса сущностью.
Если админ - безусловный поиск по params[:finder_column]. Если не админ (нет прав), то поиск по params[:finder_column], auth_column: <переданный аргумент, например, user_id. Лучше это иллюстрирует следующий код

Методы из application_controller. Первый метод для конкретного параметра (не гибкий):


    def set_user_id
      if current_user.has_role?(:admin)     ### dublication here and
        @user_id = params[:user_id]         ### every action also has an unnecessary assigment (like @entity.user_id = @user_id) :TODO:
        logger.info "User_id #{@user.try(:id)} retrieved from body request"
      else
        @user_id = current_user.id
        logger.info "User_id #{@user.try(:id)} extracted from current_user"
      end
    end

Переписанный метод, который уже принимает параметры в коллбэке

    def set_entity(obj, model, param_col, auth_col, &fallback_action)

      if current_user.has_role?(:admin)
        instance_variable_set(obj, model.find_by(id: params[param_col]))
      else
        instance_variable_set(obj, model.find_by(Hash[:id, params[param_col], auth_col, current_user.id]))
      end

      yield unless instance_variable_get(obj)
    end

Пример коллбэков из контроллера:

    before_action :set_user_id, only: [:create]

    before_action only: [:create] do
      set_entity(@user_id, Profile, :id){render(json: {"redirect_url":"profiles/new"}, status: 302)}
    end

Однако, возникла проблема: при "большом расстоянии" сущности от юзера (например, юзер хочет отредактировать период, который принадлежит его дому), даже переписанный метод не справляется. Было решено определять в модели специальную "модель-владельца". Эти модели в конечном итоге приводят к юзеру. После чего был создан рекурсивный метод для определения владельца сущности через потенциально бесконечное число связей. Результатом и является этот небольшой гем.

(еще один пример. Для получения книги в библиотеке вам нужно предъявить читательский билет.)
(для универсальности этой схемы у каждого ресурса должен быть обязательный идентификатор?)
